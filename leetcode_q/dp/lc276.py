class Solution:
    def numWays(self, n: int, k: int) -> int:
        # 基础情况：如果只有一个栅栏，可以用k种颜色中的任何一种来涂色
        if n == 1:
            return k
        # 基础情况：如果有两个栅栏，它们可以是相同的颜色或不同的颜色
        # 相同颜色：k种方式（每种颜色一种方式）
        # 不同颜色：第一个栅栏k种选择，第二个栅栏k-1种选择
        if n == 2:
            return k + k * (k - 1)

        # 初始化动态规划数组，全部元素为0
        dp = [0 for _ in range(n)]
        # 第一个栅栏可以用k种方式涂色
        dp[0] = k
        # 第二个栅栏如果与第一个栅栏相同，有k种方式，如果不同，则有k*(k-1)种方式
        dp[1] = k + k * (k - 1)

        # 计算每个后续栅栏的涂色方式
        for i in range(2, n):
            # dp[i-1] * (k - 1)：将第i个栅栏与第i-1个栅栏涂成不同颜色的方式
            # dp[i-2] * (k - 1)：将第i个栅栏与第i-2个栅栏涂成不同颜色的方式，
            # 确保没有三个连续的栅栏是同一颜色
            dp[i] = dp[i - 1] * (k - 1) + dp[i - 2] * (k - 1)

        # dp数组的最后一个元素给出涂色n个栅栏的总方式数
        return dp[n - 1]